---
layout: default
---



     
     
         <div class="Card Shadow--z2">
      <div class="Card-imgContainer">
      <img src="/images/highlight/graph_coloring.png">
      </div>
      <div class="Card-heading">
         <span>Hardness of Graph Coloring</span>
      </div>
      <div class="Card-caption">
        March 24th, 2014
      </div>
      <div class="Card-lower">
       In joint work with Irit Dinur, Prahladh Harsha, Srikanth Srinivasan [DHSV14], we show that
assuming a version of UGC, given a (almost) $3$-colorable graph, no efficient algorithm can find a $2^{poly(\log \log n)}$-coloring. This is 
an improvement over $C=poly(\log \log n)$ hardness result of Dinur and Shinkar, using similar assumtions.
      </div>
      <div class="Card-bottom">
         <a href="http://arxiv.org/abs/1411.3517">DHSV14</a>
      </div>
    </div>
    
             <div class="Card Shadow--z2">
      <div class="Card-imgContainer">
            <img src="/images/highlight/hypergraph_coloring.png">
      </div>
      <div class="Card-heading">
         <span>Hardness of Hypergraph Coloring</span>
      </div>
      <div class="Card-caption">
        March 24th, 2014
      </div>
      <div class="Card-lower">
      For the problem of $C$-coloring a $4$-colorable $4$-uniform hypergraph,
       we show that no efficient algorithm can guarantee $C=2^{(\log n)^{1/19}}$. This is an improvement over $C=poly(\log n)$. The final result is obtained using the quadratic outer verifier of Khot and Saket. 
      </div>
      <div class="Card-bottom">
         <a href="http://arxiv.org/abs/1311.7407">GHHSV14</a>  <a href="http://arxiv.org/abs/1408.0262v3">V14</a>
      </div>
    </div>
    
             <div class="Card Card-nopic Shadow--z2">
     
      <div class="Card-heading">
         <span>A characterization of hard-to-cover CSPs</span>
      </div>
      <div class="Card-caption">
        March 24th, 2014
      </div>
      <div class="Card-lower">
       In joint work with Amey Bhangale and Prahladh Harsha [BHV14], we show that no efficient algorithm can approximate the covering problem for any non-odd predicate within any constant. This leads to a complete characterization of hard-to-cover predicates as odd-predicates are always coverable by an
       assignment and its complement.
      </div>
      <div class="Card-bottom">
         <a href="http://arxiv.org/abs/1411.7747">BHV14</a>
      </div>
    </div>
    
       <div class="Card Shadow--z2">
      <div class="Card-imgContainer">
                  <img src="/images/highlight/physarum_maze.png">
      </div>
      <div class="Card-heading">
         <span>Physarum can compute shortest paths</span>
      </div>
      <div class="Card-caption">
        March 24th, 2014
      </div>
      <div class="Card-lower">
Physarum or slime
mold is a fungi. Researchers observed that it
 has fascinating computational capabilities like solving a
maze, even without a central coordination mechanism. They
modeled the creature grown in a maze with food at end points, as a
flow of fluid over a graph of tubes, with time varying diameters.
The model can be implemented in a highly distributed fashion 
as the rules for varying the diameters are local.
Simulations of this model revealed that the diameters of tubes along
the shortest paths converged to 1 and the rest to 0.  
\para
I have
 worked with Vincenzo Bonifaci and 
Kurt Mehlhorn on proving these convergence results formally for all graphs. We
used tools from electrical network and network flow theory
 to show exponential rate of convergence for a large class of
graphs to the shortest path. 
      </div>
      <div class="Card-bottom">
         <a href="https://www.youtube.com/watch?v=czk4xgdhdY4">Youtube</a>     <a href="http://arxiv.org/abs/1106.0423">BMV11</a>
      </div>
    </div>
    
     <div class="Card Card-nopic Shadow--z2">

      <div class="Card-heading">
         <span>Streaming algorithms for language recognition problems</span>
      </div>
      <div class="Card-caption">
        March 24th, 2014
      </div>
      <div class="Card-lower">
Streaming algorithms are motivated by
situations where the input data is huge and is read in an online
fashion. The efficiency of algorithms is measured with respect to the
space used. In  joint work with Ajesh Babu, Nutan Limaye and
Jaikumar Radhakrishnan, we studied streaming algorithms for checking whether an
input string(of length $n$) can be parsed in a fixed context free
grammar. Even for simple grammars, one can prove that deterministic
algorithms cannot do anything better than storing the entire input.
Using the technique of fingerprinting, we gave a randomized
streaming algorithm that uses only $\log n$ space, for a sub-class
of context free grammars [BLRV13]. We also showed that for simple
grammars outside this class, any
randomized algorithm will require $\Omega(n)$ space. Furthermore we gave an $O(\log n)$ space
randomized streaming algorithm for checking degree sequence of a
graphs~(where $n$ is the number of vertices), and prove that it is
optimal in its space usage.
      </div>
      <div class="Card-bottom">
         <a href="http://arxiv.org/abs/1104.0848">BLRV13</a>
      </div>
    </div>
    
    
