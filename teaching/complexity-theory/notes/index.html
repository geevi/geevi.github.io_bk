<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="A Short Course on Complexity Theory">

<title>A Short Course on Complexity Theory</title>
<link rel="stylesheet" href="style.css">




</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [('Table of contents',
               0,
               'table_of_contents',
               'table_of_contents'),
              ('Lecture 1: Introduction', 0, None, '___sec0'),
              ('Decision Problems', 1, None, '___sec1'),
              ('Turing Machines', 1, None, '___sec2'),
              ('Robustness of TM', 2, None, '___sec3'),
              ('Efficient Algorithms', 1, None, '___sec4'),
              ('Polynomial time vs Exponential Time', 2, None, '___sec5'),
              ('Readings', 1, None, '___sec6'),
              ("Lecture 2: Paradox's and Diagonalization",
               0,
               None,
               '___sec7'),
              ("Russell's Paradox and Diagonalization", 1, None, '___sec8'),
              ('Universal Turing Machines', 1, None, '___sec9'),
              ('Halting Problem', 1, None, '___sec10'),
              ('Lecture 3: Non Determinism, NP and Search Problems',
               0,
               None,
               '___sec11'),
              ('Non Deterministic Turing Machines', 1, None, '___sec12'),
              ('Nondeterministic Polynomial Time : NP', 1, None, '___sec13'),
              ('NP : Verifier Definition', 1, None, '___sec14'),
              ('Descision vs Search Problems', 1, None, '___sec15'),
              ('Lecture 4: Reductions, Cook-Levin Theorem and NP-Completeness',
               0,
               None,
               '___sec16'),
              ('Polynomial Time Reductions', 1, None, '___sec17'),
              ('Cook-Levin Theorem', 1, None, '___sec18'),
              ('NP Compeleness / Hardness', 1, None, '___sec19')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



    
<!-- ------------------- main content ---------------------- -->



<center><h1>A Short Course on Complexity Theory</h1></center>  <!-- document title -->

<p>
<!-- author(s): Girish Varma EMAIL: girish.varma@iiit.ac.in -->

<center>
<b>Girish Varma EMAIL: girish.varma@iiit.ac.in</b> 
</center>

<p>
<!-- institution -->

<center><b>Machine Learning Lab, IIIT Hyderabad</b></center>
<br>
<p>
<center><h4>Oct 14, 2017</h4></center> <!-- date -->
<br>

<h1 id="table_of_contents">Table of contents</h2>

<p>
<a href="#___sec0"> Lecture 1: Introduction </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> Decision Problems </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> Turing Machines </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec3"> Robustness of TM </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Efficient Algorithms </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#___sec5"> Polynomial time vs Exponential Time </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> Readings </a><br>
<a href="#___sec7"> Lecture 2: Paradox's and Diagonalization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Russell's Paradox and Diagonalization </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> Universal Turing Machines </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Halting Problem </a><br>
<a href="#___sec11"> Lecture 3: Non Determinism, NP and Search Problems </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Non Deterministic Turing Machines </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Nondeterministic Polynomial Time : NP </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> NP : Verifier Definition </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec15"> Descision vs Search Problems </a><br>
<a href="#___sec16"> Lecture 4: Reductions, Cook-Levin Theorem and NP-Completeness </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Polynomial Time Reductions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Cook-Levin Theorem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> NP Compeleness / Hardness </a><br>
</p>
<p>

<center><h1 id="___sec0">Lecture 1: Introduction </h1></center> <hr>

<p>
You have seen algorithms for a variety of problems. This begs the question
of <em>whether there is an algorithm for any  given problem?</em>. 
Furthermore <em>is there an efficient 
algorithm for all problems?</em>. Even if you have an algorithm for the problem, 
<em>can it be made more efficient?</em>. This course will be addressing these 
questions. For answering these questions, we first need to define:

<ol>
   <li> What is a <em>problem</em>?</li>
   <li> What is computer/programing language, where you can execute/write 
      the algorithms?</li>
   <li> What do you mean by <em>efficient</em>?</li>
</ol>

We will start with very simplified definitions for these questions and 
try to find the answers for this setting.

<h1 id="___sec1">Decision Problems </h1>

<p>
Typically the output of an algorithm could be a graph, a number etc. 
But we will consider only problems with an YES or NO answer. Furthermore,
we will define the problem to be just the set of all YES-instances. 
You are familiar with this definition from your automata theory class. 
For example take the REACHABILITY problem where the input is \( (G(V,E), s,t) \)
where \( s,t \in V \), and the problem is whether there is a path from \( s \) to 
\( t \) in the graph \( G \). So we will define the problem itself as the set of instances \( (G,s,t) \)
where a path exists.

$$
\mbox{REACHABILITY} = \{ (G,s,t) : \mbox{ there is a path in $G$ from } s \mbox{ to } t \}
$$

<p>
The number of instances of graphs having a particular number of vertices \( n \) 
is finite. But the set of all instances is the union of such instances with
\( n=1 \) to \( \infty \). Hence each instance has a <em>size</em> \( n \) which is the 
number of vertices in the graph. Size of an instance is a fundamental concept,
and we will be defining it for all the instances. Later we will see, that size
plays an important role in defining what we mean by an efficient algorithm.

<p>
It was easy to define REACHABILITY because the original problem had an YES or
NO answer. But can we write problems for which the outputs are numbers, as 
decision problems? Lets consider the the problem of finding the <em>chromatic 
number</em> of a graph. Chromatic number of a graph \( G \) is the minimum number of
distinct colors required to color a graph such that for every edge, end points
are of different colors. Note that for a graph on \( n \) vertices, the chromatic number is \( \leq n \).

<p>
The descision version of the chromatic number problem  takes the graph \( G \) and a number \( k \) between \( 1 \) and \( n \) as input. The output is YES, if the chromatic number is \( \leq k \). So 

$$
\text{CHROMATIC-NUMBER} = \{ (G,k) : \text{ chromatic number of graph } G \text{ is } \leq k \}
$$

<p>
Suppose you have an algorithm that takes \( T(n) \) steps for deciding the CHROMATIC-NUMBER problem, 
you can find the chromatic number also. For this we will create \( n \) instances of CHROMATIC-NUMBER
from the input graphs, setting \( k=1 \) to \( n \). Note that these instances will transition from NO-instances
to YES-instance and remain YES-instances. The chromatic number is the least \( k \) for which the instance
is an YES-instance. Hence you have algorithm which takes \( n\times T(n) \) steps for finding the exact 
chromatic number.

<p>
 <div class='problem'>
                <b>Problem 1: </b> Can you find a algorithm, which takes \( (\log n) T(n) \) steps?

<p>
</div>

<h1 id="___sec2">Turing Machines </h1>

<p>
The simplfied model for computer/programming language will be the Turning Machine (TM).
The discovery of the TM has a long and interesting history. See <a href="https://www.amazon.in/Logicomix-Epic-Search-Trurh-Truth/dp/0747597200/ref=sr_1_1?s=books&ie=UTF8&qid=1506918619&sr=1-1&keywords=logicomix" target="_self">Logicomix</a>,
for a nice read in comic book format.

<p>
The Turing Machine has many tapes (which is similar to the hard disk in 
a modern computer) and a limited set of states (which is similar to the RAM or the cache).
There is a read-only input tape, where the input is written and a write-only output
tape where the output is expected when machine is finished. There is also multiple
work tapes, which can be used for storing intermediate results in the computation.
The work tapes are assumed to be of infinite length. This is needed because as 
the size of the input instances becomes larger, the intermediate memory also needs to 
be large. The set of states of the TM is fixed and does not change with input size.

<p>
The input is assumed to be a string from a finite alphabet \( \Sigma \). A tape cell
can store an additional blank symbol indicating that it is unused.

<p>
The algorithm is implemented in a TM by means of a state function. The state
function takes as arguments:

<ol>
   <li> the symbol under the heads of the TM in each of the tapes,</li> 
   <li> well as the current state</li> 
</ol>

and returns 

<ol>
   <li> the next state</li>
   <li> the symbols to be written under each of the work tape heads</li>
   <li> the directions to move each of the heads one cell to the left, right or not move.</li>
</ol>

Now we define a TM using mathematical notation. \( \Sigma \) is the alphabet 
in which input and work tape is written (for eg. binary ie. \( \Sigma = \{0,1\} \)). 
The blank symbol for unwritten tape cell is \( \_ \). 
Let \( \Omega \) be the set of states of the TM. There are 2 special states of the
TM called \( \omega_{\text{start}} \) and \( \omega_{\text{stop}} \) called the start
and the stop states. The state transition function is denoted by 
$$
\delta : \Omega \times \Sigma \cup \{ \_ \} \rightarrow \Omega \times \Sigma^k \times \{ < , > , - \}^{k+2}
$$

<p>
Now lets see an example of a TM for solving the following problem:
$$
PALINDROMES = \{ x \in \{0,1\}^n : x \text{ is a palindrome}\}
$$

<p>
First lets try to write a pseudo code for a TM solving the problem:

<ol>
   <li> Copy the input in to the second tape</li> 
   <li> Move the head in the input tape to end and second tape to begining</li>
   <li> Compare each bit by moving the input head from end to beggining and second head from beggining to end</li>
   <li> If any bit is different reject</li>
   <li> If all bits match accept</li>
</ol>

We will use a turing machine simulator for implementing this. 
See the example : <a href="http://turingmachinesimulator.com/shared/oihvkhvacu" target="_self"><tt>http://turingmachinesimulator.com/shared/oihvkhvacu</tt></a>

<p>
Note that it is extremely tedious to write algorithms as a TM. Neverthless, all the 
algorithms can be written as TM.

<p>
 <div class='problem'>
                <b>Problem 2: </b> Design a TM which decides the language :
$$
DIV5 = \{ x \in \{0,1\}^n : x \text{ is binary number divisible by } 5\}
$$

<p>
Write the program first as a pseudo code and then in the format in <a href="https://turingmachinesimulator.com/." target="_self"><tt>https://turingmachinesimulator.com/.</tt></a>

<p>
</div>

<p>
We will use a word "decidable" to indicate that a descision problem is solvable.
A TM is said to decide a descision problem if there is a TM, that accepts
all the YES-instances and rejects all other strings. Note that this TM will never 
go  into an infinite loop.

<h2 id="___sec3">Robustness of TM </h2>

<p>
We will now see that doing some modifications to the TM definitions, does not change what it can compute. We will not be going into details, but only sketch the proof.

<p>
<b>Convert \( k \) tape TMs to single tape TMs.</b>

<p>
We will merge the \( k \) tapes in to a single tape which has an alphabet that encodes all the \( k \) symbols. But we will also need to encode whether the head in the \( k \) tape TM was placed over a symbol. So if the orignal alphabet was \( \{0,1\} \) then the new alphabet will be \( \{0,1, \dot 0, \dot 1 \}^k \).

<p>
Each step of the \( k \) tape TM will be simulated by the one tape TM, by doing a full pass over its tape, reading all the alphabets with \( \{\dot 0, \dot 1\} \). Then it will erase and the write the dots according to the appropriate tape movement (given by the transition function of the old TM).

<p>
<b>Convert alphabet from any \( \Sigma \) to binary.</b>

<p>
Suppose we have a TM with alphabet size \( |\Sigma| = t \). We will encode the \( t \) symbols into binary strings of length \( \log t \). For each step of the old TM, the new TM will go over \( \log t \) positions in its binary tape to read the symbol, and update \( \log t \) positions for writing the new symbol according to the transition funciton of the old TM.

<p>
It is important to note that, while doing these transformations, the alphabet size \( |\Sigma| \) and the state size \( |\Omega| \) remain constant, independent of the input size.

<h1 id="___sec4">Efficient Algorithms </h1>

<p>
Recall that for every instance of a problem, we will have a size defined (denoted by \( n \)).
The number of steps taken by the TM to decide an instance will grow with \( n \).
Hence the running time of a problem will be defined in terms of the size \( n \).
Futhermore we will be considering <em>worst case</em> running time. That is the running time
for intances of size \( n \) will be defined as the the largest running time,
among all intances of size \( n \).

<p>
For example, consider the Dijkstra's algorithm for 
shortest path. There are instances of graph of size \( n \) like a 
\( n \) length path on which the algorithm takes only \( O(n) \) steps. However if the 
graph is a complete graph, it takes \( O(n^2) \) steps. But it never takes more than
\( O(n^2) \) steps on instances of size \( n \). Hence running time of Dijkstra's
algorithm will be considered as \( O(n^2) \).

<p>
 <div class='problem'>
                <b>Problem 3: </b> Let \( f(n) \) and \( g(n) \) be any two of the following functions. Determine whether
\( f(n) = O(g(n)) \),  \( f(n) = \Omega(g(n)) \) and \( f(n) = \Theta(g(n)) \).

<ol>
   <li> \( n! \)</li>
   <li> \( n^{\log n} \)</li>
   <li> \( n^2 \) when \( n \) is odd and \( 2^n \) otherwise</li>
   <li> \( n^3 \)</li>
   <li> \( n^{n} \)</li>
   <li> \( 2^n \)
            </div></li>
</ol>

<h2 id="___sec5">Polynomial time vs Exponential Time </h2>

<p>
Now lets consider the CHROMATIC-NUMBER problem. There is very simple brute force
algorithm for it. Given an instance \( (G,k) \), for every assignment of \( k \) colors to 
the vertices, check for every edge, that the end points have different colors. If we 
find a color assignment which passes all checks, the TM can say YES. If for all 
assignments some check fails, then the TM says NO. This is a valid algorithm. Note
that for a NO-instance, the TM has to loop over all the color assignments which is
\( k^n \) in number, and do all the checks for each edge. Hence the running time is \( O(k^n\times n^2) \).

<p>
Note that the running time for the above algorithm grows exponentialy in \( n \). Even if
\( n=100 \), the running time is a very huge number that even a fast computer cannot hope
to solve it. So now the question is where there is another algorithm for CHROMATIC-NUMBER,
which is faster.

<p>
Our definition of efficient algorithms will be <em>polynomial time algorithms</em>, that is 
algorithms for which the running time is of the form \( O(n^t) \) for some fixed integer \( t \).

<h1 id="___sec6">Readings </h1>

<p>
<b>Chapter 3.</b>

Michael Sipser, Introduction to Theory of Computation

<p>
<b>Chapter 1, Chapter 2.</b>
Christos Papadimitriou, Computational Complexity

<p>
<b>Misc: </b>
<a href="https://www.amazon.in/Logicomix-Epic-Search-Trurh-Truth/dp/0747597200/ref=sr_1_1?s=books&ie=UTF8&qid=1506918619&sr=1-1&keywords=logicomix" target="_self">Logicomix</a>

<center><h1 id="___sec7">Lecture 2: Paradox's and Diagonalization </h1></center> <hr>

<h1 id="___sec8">Russell's Paradox and Diagonalization </h1>

<p>
<em>There is a village where the barbers shave only those people who 
do not shave by themselves. Now does a barber shave himself?</em>

<p>
If YES, then he cannot shave himself. If NO, then he can shave himself.

<p>
See <a href="https://www.amazon.in/Godel-Escher-Bach-Eternal-Golden/dp/0140289208" target="_self">Godel, Escher, Bach</a>,
for more paradoxes and their history.

<p>
Now we will solve a problem using the Russell's paradox. 
Let \( \mathbb N \) be the set of natural numbers and \( \mathcal{P}(N) \) is the set of all
subsets of \( \mathbb N \) (or the power set of \( \mathbb N \)). Show that there cannot 
be a one to one mapping between \( \mathbb N \) and \( \mathcal{P}(N) \) that has range 
equal to \( \mathcal{P}(N) \) (that is for every subset of \( \mathbb N \), there is some 
integer that maps to it).

<p>
Suppose there is a one to one mapping \( f \) that has range 
equal to \( \mathcal{P}(N) \). Consider the set 
$$
S = \{ x : x \notin f(x) \}
$$

Since \( f \) that has range equal to \( \mathcal{P}(N) \), there is some 
integer \( y \) that maps to \( S \) (that is \( f(y) = S \)). Now does \( y \in S \)?

<p>
 <div class='problem'>
                <b>Problem 4: </b> Let STRINGS be the set of all infinite length binary sequences. That is 
$$
\text{STRINGS} = \{ x:\mathbb{N} \rightarrow \{0,1\}  \}
$$

That is any infinite length binary sequence is simply a function that maps every integer 
to the bit at the corresponding position. Show that there cannot 
be a one to one mapping between \( \mathbb N \) and STRINGS.

<p>
</div>

<h1 id="___sec9">Universal Turing Machines </h1>
Computer as we know them are general purpose machines. That is, you can give them
any program in a particular format (a programming langauge, or assembly), and they
can execute it. However the Turing Machines that we saw in the previous lecture,
seems to be tailor made for a particular problem.

<p>
The first step to making Turing Machines general purpose is to encode a TM as a string,
which could be fed as input to a general purpose TM, which we will call Universal Turing
Machines. As we saw previously, a TM is a tuple 

$$
M = (\Omega, \Sigma, \mathcal{T}, \delta, \omega_{\text{start}}, \omega_{\text{accept}}, \omega_{\text{reject}})
$$

<p>
where \( \Omega \) is a set of states, \( \Sigma \) is the alphabet for the language, \( \mathcal{T} \) is the tape 
alphabet, \( \delta \) is a transition function and \( \omega_{\text{start}}, \omega_{\text{accept}}, \omega_{\text{reject}} \)
are the special start, reject, accept states respectively. Note that the states, the alphabets and the special states,
are all finite and can be encoded as a finite alphabet. \( \delta \) function also is finite and could be represented as 
a set of rules (similar to how the turning machine simulater is doing). We will denote the string representing a
TM \( M \) by \( \langle M \rangle \).

<p>
A Universal Turing Machine takes a string \( (\langle M \rangle, x) \), and simulates the running of the TM \( M \) on the 
input \( x \). It is just another TM having its own transition function, alphabets and states. However it is designed
such that it can accept a TM encoding \( \langle M \rangle \) as in part of the input, and the transition function
is defined such that it simulates the running of \( M \) on a string \( x \).

<p>
<b>Configuration.</b>
An important concept for doing simulation is the configuration of a TM. Lets 
stick to 1-tape TMs for now. The "state" of the algorithm (not the TM state) is
really consist of the the TM's state, the contents of its tape as well as the position
of the tape heads. If a TM is at state \( \omega_i \), has the string 101101111 in 
its tape and the tape head is at the 5th position, then its current configuration is 
1011 \( \omega_i \) 01111. Note that this is a string over the alphabet \( \mathcal{T} \cup \Omega \). 
The computation of TM is a graph in the space of all TM configurations. If the TM 
halts, it is a path which ends in a configuration having an accept or reject state.
If it loops, there will be a cycle in this graph.

<p>
A universal TM, goes over a configuration string, then goes over the encoding of the delta function,
finds out which rule in the delta function to use, and can update the configuration,
to reflect the next configuration of the TM begin simulated.

<h1 id="___sec10">Halting Problem </h1>

<p>
Recall that we started with the question whether all problems can be solved by a TM.
Consider the following descision problem:
$$
H = \{ (\langle M \rangle,x) : M \text{ accepts } x \}
$$

That is, given a TM encoding \( \langle M \rangle \) and a string \( x \), check if 
\( M \) accepts \( x \). Can you think of a TM which decides \( H \). One way is to simulate \( M \) on \( x \)
like the universal TM. But its possible that \( M \) loops on \( x \) and the UTM will also loop.

<p>
Suppose there a TM \( M_H \) which decides \( H \). We will define a new TM \( D \) which takes an encoding
of a TM \( \langle M \rangle \) as input , which does
the following 

<ol>
   <li> Run \( M_H \) on \( (\langle M \rangle, \langle M \rangle) \).</li>
   <li> Output the opposite of what \( M_H \) outputs.</li>
</ol>

So \( D \) accepts \( \langle M \rangle \) if \( M \) rejects the input \( \langle M \rangle \) and 
it rejects of if \( M \) accepts the input \( \langle M \rangle \). Now the question is 
what is the output of of \( D \) when run on \( \langle D \rangle \)?

<p>
You will see that there is a problem, very similar to the Russell's paradox here. Hence 
there cannot be a TM \( D \). But we can construct \( D \) if there is a TM \( M_H \). So 
neither can there be a TM \( M_H \) which decides \( H \).

<p>
\( H \) is popularly known as the halting problem which was shown by Turing to be not
decidable (or undecidable).

<p>
 <div class='problem'>
                <b>Problem 5: </b> Let \( \text{EMPTY} = \{ \langle M \rangle : M \text{ rejects all inputs } \} \). Show 
that this problem is undecidable.

<p>
</div>

<p>

<center><h1 id="___sec11">Lecture 3: Non Determinism, NP and Search Problems </h1></center> <hr>

<h1 id="___sec12">Non Deterministic Turing Machines </h1>

<p>
Last lecture we saw that TM's can be encoded as strings and simulated by a
universal TM using the configurations. We also saw that simulation of a TM,
is essentialy tracing a path in the configuration space. But in the TMs that 
we defined, the out degree of any node (a configuration) 
in the graph (in the configuration space) is one.

<p>
Similar to the Nondeterministic finite automata, we can also define TMs 
with delta rules that results in multiple next states 
(called Nondeterministic Turing Machines or NTMs). Then the delta rules
will be of the form \( \delta:\Omega\times \mathcal{T} \rightarrow \mathcal{P}(\Omega\times \mathcal{T}\times \{\langle, \rangle, -\}) \).
(\( \mathcal{P} \) denotes the power set). So the configuration graph of a 
NTM can have out degree greater than \( 1 \). However the it still has to be a finite 
number since the size of \( \mathcal{P}(\Omega\times \mathcal{T}\times \{\langle, \rangle, -\}) \) is 
finite. Following the different paths, an NTM could accept, reject or keep looping.
So we need to define what is meant by deciding a language by an NTM.

<p>
An NTM is said to decide a language (a descision problem) \( L \) iff,
for all strings in the language, there exists one path in the configuration 
space that results in accept state.  For strings not in the language, all 
paths in the configuration space should result in reject state.

<p>
We know that NFA (Nondeterministic Finite automata) can always be converted to 
a deterministic one. However for Pushdown Automaton this coverstion is not possible
always. We will see that for TMs, this conversion can always be done. That is the 
set of languages that can be decided by TMs does not change by allowing 
nondeterminism.

<p>
Recall that UTM simulated a deterministic TM, by tracing the path in the configuration
space. But for NTMs, the graph in the configuration space is a tree. A simple 
idea is for a UTM to do a graph traversal. DFS might be a bad idea, because
some of the paths go into infinite loops. Hence it can to BFS. The first time,
it finds that the NTM has reached the accept state, the UTM can also accept.
If it never finds an accept state, the simulating TM rejects.

<h1 id="___sec13">Nondeterministic Polynomial Time : NP </h1>

<p>
As we disscussed earlier, an NTM can take different paths in the configuration space.
The length of the path is essentialy the number of steps. Now we will define 
the worst case running time for a NTM.

<p>
For a language \( L \), on inputs of size \( n \), the worst case running time of an NTM 
is the length of the longest path in the configuration space on any of the inputs 
of size \( n \).

<p>
NP or Nondeterministic Polynomial time  is the class of descision problems for which,
there is an NTM which decides it in worst case polynomial time.

<h1 id="___sec14">NP : Verifier Definition </h1>

<p>
We will define descision problems that are <em>verifiable</em>. A descision problem 
is said to be verifable if there exists  a deterministic TM \( M \) that takes two 
inputs \( (x,y) \) where \( x \) is an instance of the descision problem and \( y \) is
called a certificate which has length of  atmost \( p(n) \) where \( p \) is a polynomial. 
For YES-instances \( x \), there should exist a certificate 
\( y \) such the \( M \) accepts the input \( (x,y) \). For instances not in the language,
for every \( y \) of length \( p(n) \), \( M \) should reject on \( (x,y) \). Also the running
time of \( M \) must be polynomial time in size of \( x \).

<p>
 <div class='problem'>
                <b>Problem 6: </b> Show that NP is the same as the set of verifable languages.

<p>
</div>

<p>
An example of a verifiable language is the Clique problem.

$$
\text{CLIQUE} = \{ (G,k): G \text{ has a clique of size } k  \}
$$

<p>
A certificate for YES-instance \( (G,k) \),  is just the list of vertices in a \( k \)-clique.
The polynomial time verifier just checks if there is an edge between all pairs of
vertices. If \( (G,k) \) is not in the language, then for any set of \( k \) vertices,
that you can give to the verifier, it will reject, since there will not be an 
edge between some pair in the list.

<p>
 <div class='problem'>
                <b>Problem 7: </b> Show that the CHROMATIC-NUMBER problem defined in Lecture 1 is verifiable.

<p>
</div>

<h1 id="___sec15">Descision vs Search Problems </h1>

<center><h1 id="___sec16">Lecture 4: Reductions, Cook-Levin Theorem and NP-Completeness </h1></center> <hr>

<p>
The notes are mostly from Section 7.4, 7.5 in the Sipser book.

<h1 id="___sec17">Polynomial Time Reductions </h1>

<p>
Last lecture, we showed that for some problems, the search problem can be solved in polytime,
if the corresponding desciion problem can be solved in polytime. In this lecture,
we will show that many desicion problems can be solved by solving one particular 
desciion problem called \( 3 \)-SAT.

<p>
For this we need first define a reduction. The following problems were defined previously

<ol>
   <li> \( 3 \)-SAT = \( \{ \phi : \phi \text{ is a 3CNF formula that is satisfiable} \} \).</li>
   <li> CLIQUE = \( \{ (G,k) : G \text{ has a clique of size } k \}. \)</li>
</ol>

We will say that \( f \) is a (poly time) reduction from \( 3 \)-SAT to CLIQUE, if it maps \( 3 \)-CNF formulas \( \phi \)
to a tuple \( (G,k) \) where \( G \) is a graph and \( k \) is a number such that 

<ol>
   <li> \( f \) can be computed by a polynomial time TM.</li>
   <li> \( \phi \) is satisfiable if and only if \( G \) has a \( k \) clique.</li>
</ol>

If we have such an \( f \), any polynomial time algorithm for CLIQUE can be used to 
design a polynomial time algorithm for \( 3 \)-SAT.

<p>
 <div class='problem'>
                <b>Problem 8: </b> If we have such an \( f \), give a polynomial time algorithm for \( 3 \)-SAT, 
assuming there is a polynomial time algorithm for CLIQUE.

<p>
</div>

<p>
The algorithm for computing \( f \) is as follows:

<ol>
   <li> For every clause in \( \phi \), put \( 3 \) new verticies correponding to each literal in the clause.</li>
   <li> Put all edges in the graph except:

<ol type="a"></li>
       <li> between the 3 veritices correponding to the same clause.</li>
       <li> \( x_i \) an \( \bar x_i \) for all \( i \).</li>
</ol>

   <li> Set \( k \) to be equal to the number of clauses.</li>
</ol>

 <div class='problem'>
                <b>Problem 9: </b> Verify the following:
   <li> \( f \) is polynomial time.</li>
   <li> Show that if \( \phi \) is satisfiable \( G \) has a \( k \) CLIQUE.</li>
   <li> Show that if \( G \) has a \( k \) CLIQUE then \( \phi \) is satisfiable.

<p>
</div>

<p>
Such a reduction says that CLIQUE is a harder problem than \( 3 \)-SAT, because an algo for 
CLIQUE gives an algo for \( 3 \)-SAT and we dont know if the reverse is True. Hence it is denote as
$$ \text{CLIQUE} \geq_p 3\text{-SAT}.$$

<h1 id="___sec18">Cook-Levin Theorem </h1>
The Cook-Levin Theorem tells that the reverse reduction also exists. In fact,
it states that any language in NP can be reduced to SAT

<p>
<b>Cook-Levin Theorem.</b>
For any language \( L \in NP \), SAT \( \geq_p  \) L.

<p>
For doing this, for any language \( L \), that has a nondeterministic polynomial time TM,
we need to come up with a polynomial time reduction, which satisfies the conditions,
given in the previous section.

<p>
See Theorem 7.37 for the proof of Cook-Levin Theorem.

<h1 id="___sec19">NP Compeleness / Hardness </h1>

<p>
Vertex Cover 3SAT Reduction.

<p>
SAT 3SAT Reduction.

<p>

<!-- ------------------- end of main content --------------- -->


<center style="font-size:80%">
<!-- copyright --> &copy; 2017-2017, Girish Varma EMAIL: girish.varma@iiit.ac.in
</center>


</body>
</html>
    

